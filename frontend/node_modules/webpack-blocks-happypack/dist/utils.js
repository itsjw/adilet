'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeRule = exports.extractAllowedLoaders = exports.extractLoaders = exports.getAllowedLoadersPattern = exports.getRules = exports.createRuleId = exports.createRuleHash = exports.createHappyConfig = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _kebabCase = require('lodash/kebabCase');

var _kebabCase2 = _interopRequireDefault(_kebabCase);

var _flatten = require('lodash/flatten');

var _flatten2 = _interopRequireDefault(_flatten);

var _uniq = require('lodash/uniq');

var _uniq2 = _interopRequireDefault(_uniq);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

const createHappyConfig = (_ref = {}) => {
  let cache = _ref.cache,
      cacheContext = _ref.cacheContext,
      refresh = _ref.refresh,
      happypackOptions = _objectWithoutProperties(_ref, ['cache', 'cacheContext', 'refresh']);

  return _extends({}, happypackOptions, {
    cache: typeof cache !== 'undefined' ? cache : !process.env.DISABLE_HAPPY_CACHE,
    cacheContext: _extends({
      env: process.env.NODE_ENV,
      refresh: refresh || process.env.REFRESH_HAPPY_CACHE ? Math.random() : 0
    }, cacheContext)
  });
};

exports.createHappyConfig = createHappyConfig;
const createRuleHash = exports.createRuleHash = rule => _crypto2.default.createHash('md5').update(JSON.stringify(rule)).digest('hex').slice(0, 8);

const createRuleId = exports.createRuleId = (rule, hash) => `${(0, _kebabCase2.default)(rule.test.source)}-${hash}`;

const getRules = exports.getRules = block => block.module ? block.module.loaders || block.module.rules : undefined;

const getAllowedLoadersPattern = exports.getAllowedLoadersPattern = allowedLoaders => new RegExp(`^(${allowedLoaders.join('|')})`, 'i');

const extractLoaders = exports.extractLoaders = rule => (0, _flatten2.default)([].concat(rule.loader || rule.loaders || rule.use || []).map(loader => typeof loader === 'string' ? loader.split('!') : [].concat(loader)));

const extractAllowedLoaders = exports.extractAllowedLoaders = (loaders, pattern) => loaders.map(loader => loader.loader || loader).filter(loader => pattern.test(loader));

const mergeRule = exports.mergeRule = (rule, originalLoaders, allowedLoaders, happypackLoaderId) => {
  const finalRule = _extends({}, rule, {
    use: originalLoaders.reduce((finalLoaders, originalLoader) => {
      const happyLoader = `happypack/loader?id=${happypackLoaderId}`;

      if (originalLoader.loader && allowedLoaders.indexOf(originalLoader.loader) >= 0) {
        // ExtractTextPlugin
        finalLoaders.push(_extends({}, originalLoader, { loader: happyLoader }));
      } else if (allowedLoaders.indexOf(originalLoader) >= 0) {
        finalLoaders.push(happyLoader);
      } else {
        finalLoaders.push(originalLoader);
      }
      return finalLoaders;
    }, [])
  });

  finalRule.use = (0, _uniq2.default)(finalRule.use);

  delete finalRule.loader;
  delete finalRule.loaders;

  return finalRule;
};